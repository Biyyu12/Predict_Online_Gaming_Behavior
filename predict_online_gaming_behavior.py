# -*- coding: utf-8 -*-
"""Predict Online Gaming Behavior

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1suYXqeIt9xaBoi5qlbSIuN0NntBlzXYF

# Predicvite analysis | Online Gaming Behavior

### Nama : Abiyyu Rasyiq Muhadzzib
### Gmail : abiyyu.rm12@gmail.com

Tujuan dari projek machine learning ini adalah memprediksi dan klasifikasi engagement player dari beberapa faktor yang mempengaruhinya. Pada projek ini menggunakan Online Gaming behavior Dataset. berikut merupakan linknya:
*   https://www.kaggle.com/datasets/rabieelkharoua/predict-online-gaming-behavior-dataset/data

# Import Library

Pada tahap ini mengimport library yang dibutuhkan
"""

import numpy as py
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import OrdinalEncoder
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

"""# Data Load"""

df = pd.read_csv('/content/online_gaming_behavior_dataset.csv')
df.head()

df.shape

"""# Data Understanding

## EDA Variabel

pada tahap ini melakukan Ekespolasi untuk mengetahui lebih detail informasi dataset
"""

df.info()

"""Bisa liat bahwa dataset mempunyai 13 variabel, dengan 8 variabel bertipe numerik dan 5 variabel bertipe objek. Berikut ini deskripsi dari masing-masing variabel
* PlayerID: Pengenal unik untuk setiap pemain.
* Age: Usia pemain.
* Gender: Jenis kelamin pemain.
* Location: Lokasi geografis pemain.
* GameGenre: Genre permainan yang dimainkan oleh pemain.
* PlayTimeHours: Rata-rata waktu bermain dalam jam per sesi.
* InGamePurchases: Menunjukkan apakah pemain melakukan pembelian dalam game (0 = Tidak, 1 = Ya).
* GameDifficulty: Tingkat kesulitan permainan.
* SessionsPerWeek: Jumlah sesi permainan per minggu.
* AvgSessionDurationMinutes: Rata-rata durasi setiap sesi permainan dalam menit.
* PlayerLevel: Level pemain saat ini dalam permainan.
* AchievementsUnlocked: Jumlah pencapaian yang telah dibuka oleh pemain.
* EngagementLevel: Tingkat keterlibatan yang mencerminkan retensi pemain ('Tinggi', 'Sedang', 'Rendah').







"""

df.describe()

"""Lalu menggunakan fungsi describe() untuk menganalisis statistik semua variabel numerik. fungsi describe() memperlihatkan mean, standar deviasi, median, nilai minimum dan nilai maksimal. Berikut ini penjelasannya


*   Pada kolom 'Age' rata-rata player adalah 32 tahun, dengan umur paling muda 15 tahun dan paling tua 49 tahun.
*   Pada kolom 'PlayTimeHours' rata-rata player bermain selama 12 jam dengan paling singkat selama >1 jam dan paling lama 24 jam.
*   Pada kolom 'InGamePurchases' rata-rata player tidak melakukan pembelian dalam game.
*  Pada kolom 'SessionPerWeek' rata-rata player bermain 9 sesi per minggu , dengan 19 sesi paling banyak.
* Pada 'AvgSessionDurationMinutes' rata-rata bermain selama 94 menit, dengan 10 menit paling cepat dan 179 menit paling lama.
* Pada 'Playerlevel' rata-rata player mencapai level 49
* Pada 'AchievementsUnlocked' rata-rata player telah membuka 24 Achievement.

## EDA Missing value dan Outlier

Pada tahap ini, memeriksa missing value dan outlier pada dataset
"""

df.isnull().sum()

"""dataset ternyata bersi dari nilai null

selanjutnya memeriksa outlier dari beberapa fitur numerik yang ada pada dataset ini dengan plotbox
"""

numeric_columns = ['Age', 'PlayTimeHours', 'SessionsPerWeek',
                   'AvgSessionDurationMinutes', 'PlayerLevel', 'AchievementsUnlocked'
                   ]

plt.figure(figsize=(20, 15))

for i, col in enumerate(numeric_columns, 1):
    plt.subplot(len(numeric_columns) // 3 + 1, 3, i)
    sns.boxplot(x=df[col])
    plt.title(f'Box plot dari {col}')

plt.tight_layout()
plt.savefig("Box plot.png", dpi=300)
plt.show()

"""Dataset juga bersih dari outliers

## EDA Univariate

selanjutnya melakukan EDA Univariate, hal ini dilakukan untuk memahami distribusi satu variabel secara mendalam.
"""

numerical_features = ['Age', 'PlayTimeHours', 'SessionsPerWeek',
                   'AvgSessionDurationMinutes', 'PlayerLevel', 'AchievementsUnlocked']
categorical_features = ['Gender', 'Location', 'GameGenre', 'GameDifficulty', 'EngagementLevel']

"""**EDA Univariate Categorical**

Mamahami distribusi variabel kategori

**Gender**
"""

feature = categorical_features[0]
count = df[feature].value_counts()
percent = 100*df[feature].value_counts(normalize=True)
Gender = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(Gender)
count.plot(kind='bar', title=feature);

"""Untuk distribsi variabel gender tidak seimbang dengan didominasi oleh laki-laki dengan persentasi 59%.

**location**
"""

feature = categorical_features[1]
count = df[feature].value_counts()
percent = 100*df[feature].value_counts(normalize=True)
Location = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(Location)
count.plot(kind='bar', title=feature);

"""Pada distribusi location terdiri dari USA, Europe, Asia, dan lain-lain. Untuk kategori location juga terlihat tidak seimbang dengan didominasi oleh USA dengan persentasi 40%.

**GameGenre**
"""

feature = categorical_features[2]
count = df[feature].value_counts()
percent = 100*df[feature].value_counts(normalize=True)
GameGenre = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(GameGenre)
count.plot(kind='bar', title=feature);

"""Untuk game genre memiliki distribusi yang seimbang.

**Game Difficulty**
"""

feature = categorical_features[3]
count = df[feature].value_counts()
percent = 100*df[feature].value_counts(normalize=True)
GameDifficulty= pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(GameDifficulty)
count.plot(kind='bar', title=feature);

"""Pada fitur game difficulty disribusi data di dominasi oleh difficulty easy

**Engagement Level**
"""

feature = categorical_features[4]
count = df[feature].value_counts()
percent = 100*df[feature].value_counts(normalize=True)
GameDifficulty= pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(GameDifficulty)
count.plot(kind='bar', title=feature);

"""Pada Feature 'EngagementLevel' menjadi variabel target. Distribusi tidak seimbang karena di dominasi Medium dengan 48% sedangkan, high dan low hanya 25%

**Univariate Numerical**
"""

df.hist(bins=50, figsize=(20,15))
plt.savefig("Univariate Numerical.png", dpi=300)
plt.show()

"""* Pada distribusi fitur numerik variabel 'Age', 'PlayTimeHours', 'SessionPerWeek', 'AchievementsUnlcoked' memiliki distribusi yang cukup seimbang.
* Untuk fitur 'InGamePurchases' didominasi oleh player yang tidak melakukan pembelian di dalam game
* Untuk kedua fitur 'AvgSessionDurationMinutes' dan 'PlayerLavel' terdapat perbedaan distribusi yang mencolok.

## EDA Multivariate

**Categorical Feature**

Melihat hubungan antara feature EngagementLevel dengan categorical feature yang lain
"""

cat_features = ['Gender', 'Location', 'GameGenre', 'GameDifficulty']

for col in cat_features:
  crosstab = pd.crosstab(df[col], df['EngagementLevel'])
  crosstab.plot(kind='bar', stacked=True, figsize=(10,6))
  plt.title(f'Engagement Level berdasarkan {col}')
  plt.xlabel(col)
  plt.ylabel('Count')
  plt.xticks(rotation=0)
  plt.legend(title='Engagement Level')
  plt.tight_layout()
  plt.savefig(f'Engagement_Level_{col}.png', dpi=300)
  plt.show()

"""Dari EDA ada beberapa insight sebagai berikut:
* untuk semua fitur kategori memiliki kesamaan yaitu engagement level medium mendominasi/memiliki jumlah paling banyak diantara level yang lain.
* Untuk lebel high dan low juga memiliki kesamaan atau perbedaan yang tidak terlalu jauh pada fitur kategori

**Numerik Feature**

setelah melihat fitur kategori, selanjutnya melihat hubungan antara engagemnet level dengan numeric feature dengan menggunakan boxplot()
"""

for col in numerical_features:
    plt.figure(figsize=(10, 6))
    sns.boxplot(x=df['EngagementLevel'], y=df[col])
    plt.title(f'{col} vs EngagementLevel')
    plt.xlabel('EngagementLevel')
    plt.ylabel(col)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.savefig(f"Multivariate_Numerical_{col}.png", dpi=300)
    plt.show()

"""Dari EDA ada beberapa insight:
* Pada 'SessionPerWeek' terhadap 'EngagementLevel' memiliki perbedaan yang jelas. Player  dengan tingkat engagement yang tinggi cenderung memiliki sesi mingguan yang lebih banyak. Akan tetapi, pada engagement level rendah dan tinggi bervariasi dalam jumlah sesi per minggu, ada beberapa player yang memiliki sesi tinggi tetapi tingkat engagement mereka dianggap rendah dan begitu sebaliknya.
* Pada 'AvgSessionDurationMinutes' juga memiliki beberapa hal menarik seperti perbedaan yang jelas antara rata-rata durasi menit player dengan engagement mereka. Akan tetapi untuk tingkat tinggi memiliki outlier dimana beberapa pemain dengan durasi menit yang rendah memiliki tingkat engagement yang tinggi


"""

mean_values = df.groupby('EngagementLevel')[numerical_features].mean(numeric_only=True)

plt.figure(figsize=(10, 6))
sns.heatmap(mean_values.T, annot=True, cmap='coolwarm', linewidths=0.5)
plt.title('Mean Values of Numerical Features by EngagementLevel')
plt.savefig("Multivariate Heatmap.png", dpi=300)
plt.show()

"""Nilai mean dari fitur numerik terhadap 'EngagementLevel' mendapatkan beberapa insight:
* Pada fitur 'SessionsPerWeek' player dengan sesi terbanyak dalam per minggu memiliki engagement level yang tinggi. sedangkan, untuk sesi sedikit memiliki engagement level yang rendah.
* Pada fitur'AvgsessionDurationMinutes' player dengan rata-rata durasi tertinggi mencapai 130 menit per sesi memiliki engagement yang tinggi, sedangkan untuk rata-rata durasi 67 menit per sesi memiliki engagement yang rendah.

# Data Preparation

Pada tahap ini untuk mempersiapkan dataset untuk melatih model machine learning. beberapa tahap yang akan dilakukan:
1. Seleksi fitur
2. Encoding fitur kategori
3. pembagian dataset
4. standarisasi

## Seleksi fitur

Tahap ini akan menseleksi fitur yang tidak berkaitan dengan fitur target 'EngagementLevel'.
"""

new_df = df.drop(['PlayerID'], axis=1, inplace=False)
new_df.head()

"""Mengehapus fitur 'PlayerID' karena 'PlayerID' hanya menjadi pengenal unik untuk setiap pemain. Jadi ini tidak ada hubungannya dengan 'EngagementLevel'.

## Encoding Fitur Kategori

Proses ini dilakukan untuk mengubah tipe objek pada kategori menjadi nilai numerik
menggunakan teknik one-hot-encoding.
"""

new_df = pd.concat([new_df, pd.get_dummies(new_df['Gender'], prefix='Gender')], axis=1)
new_df = pd.concat([new_df, pd.get_dummies(new_df['Location'], prefix='Location')], axis=1)
new_df = pd.concat([new_df, pd.get_dummies(new_df['GameGenre'], prefix='GameGenre')], axis=1)
new_df = pd.concat([new_df, pd.get_dummies(new_df['GameDifficulty'], prefix='GameDifficulty')], axis=1)
new_df.drop(['Gender', 'Location', 'GameGenre', 'GameDifficulty'], axis=1, inplace=True)
new_df = new_df.applymap(lambda x: int(x) if isinstance(x, bool) else x)
new_df.head()

"""Tahap ini juga melakukan encoder pada fitur target yaitu 'EngagementLevel' dengan teknik Odrinal-Encoder yang akan melakukan tranformasi tipe objek menjadi tipe numerik yang memiliki tingkatan."""

label_encoder = OrdinalEncoder(categories=[['Low', 'Medium', 'High']])
new_df['EngagementLevel'] = label_encoder.fit_transform(new_df[['EngagementLevel']])

new_df.head()

"""Fitur 'EngagementLevel' sudah dirubah menjadi tipe numerik. berikut ini merupakan deskripsinya:
* 0 : 'Low'
* 1 : 'Medium'
* 3 : 'High'

## Pembagian dataset

pada tahap ini kita akan melakukan pembagian dataset menjadi dataset latih dan dataset test dengan menggunakan fungsi train_test_split. Pembagian dataset yang kita lakukan adalah 90:10 karena dataset yang kita miliki 40000 data.
"""

X = new_df.drop(['EngagementLevel'], axis=1)
y = new_df['EngagementLevel']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=42)

print(f'Jumlah dataset: {len(new_df)}')
print(f'Jumlah dataset train: {len(X_train)}')
print(f'Jumlah dataset test: {len(X_test)}')

"""## Standarisasi

Pada langkah ini menerapkan standarisasi dengan StandardScaler(). Tahapan ini merupakan tahapan umum yang dilakukan untuk mempersiapkan dataset agar machien learning memiliki peforma lebih baik dan konvergen lebih cepat.

Dengan StandardScaler() sebagai teknik transformasi paling umum dilakukan. StandarScaler melakukan proses standarisasi fitur dengan mengurangkan mean kemudian membaginya dengan standar debiasi untuk menggeser distribusi. ini akan menghasilkan standar deviasi 1 dan mean 0

"""

scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

"""# Modaling

Pada tahap modeling akan dilakukan dengan algoritma machine learning untuk klasifikasi kategori. Beberapa algortima yang akan saya gunakan adalah:
1. Random Forest Classifier, ini karena Random Forest cocok untuk dataset yang besar dengan banyak fitur.
2. Logistic Regression, Algoritma yang cepat dan cocok untuk masalah klasifikasi multiclass denga fitur terstruktur.
3. Gradient Boosting Machines, Ini adalah algortima boosting yang cenderung memiliki hasil yang sangat baik untuk tugas klasifikasi, dan efisien untuk dataset besar.

## Random Forest
"""

from sklearn.ensemble import RandomForestClassifier

rf_classifier = RandomForestClassifier(n_estimators=400, max_depth=20, random_state=42, n_jobs=-1)
rf_classifier.fit(X_train, y_train)

"""## Logistic Regression"""

from sklearn.linear_model import LogisticRegression

lr_classifier = LogisticRegression(multi_class='multinomial', solver='lbfgs', max_iter=300, random_state=42)
lr_classifier.fit(X_train, y_train)

"""## XGBoost"""

import xgboost as xgb

xgb_classifier = xgb.XGBClassifier(objective='multi:softmax', num_class=3, n_estimators=250,
                                   max_depth=24, n_jobs=-1, random_state=42)
xgb_classifier.fit(X_train, y_train)

"""# Evaluasi
Pada tahap ini dilakukan evaluasi pada setiap model yang telah dilatih. Untuk metrik yang digunakan adalah akurasi dan classification_report. Classificasion_report berfungsi untuk melihat performa model dalam klasifikasi dengan model precision, recall, dan f1 score

## Random Forest
"""

from sklearn.metrics import accuracy_score
from sklearn.metrics import classification_report

y_pred = rf_classifier.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)

print(classification_report(y_test, y_pred))

"""Secara keseluruhan, model Random Forest menunjukkan performa yang baik pada dataset ini dengan akurasi tinggi 90%. Setiap kelas memiliki precision, recall, dan f1-score yang cukup tinggi, meskipun kelas 'Low' sedikit lebih baik dalam recall dan f1-score dibandingkan kelas lainnya.

## Logistic Regression
"""

y_pred = lr_classifier.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)

print(classification_report(y_test, y_pred))

"""Model Logistic Regression menunjukkan performa yang baik dengan akurasi 82%. Precision dan recall untuk kelas 'Medium' dan 'High' lebih tinggi dibandingkan kelas 'Low', menunjukkan bahwa model lebih baik dalam mendeteksi sampel kelas 'Medium' dan 'High'.

## XGBoost
"""

y_pred = xgb_classifier.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)

print(classification_report(y_test, y_pred))

"""Model XGBoost menunjukkan performa yang sangat baik dengan akurasi tinggi 91.2% dan nilai precision, recall, serta f1-score yang stabil di semua kelas. Kelas 'Medium' memiliki performa terbaik dengan recall dan f1-score yang tertinggi, menunjukkan bahwa model sangat baik dalam mendeteksi sampel kelas ini.

# Kesimpulan

XGBoost memiliki performa yang lebih baik dibandingkan Logistic Regression dan sedikit lebih baik dibandingkan Random Forest pada data ini. Hal ini menandakan bahwa XGBoost adalah pilihan yang kuat untuk dataset ini, terutama karena kemampuannya menjaga performa yang konsisten di seluruh kelas.
"""